export = IPFS;
declare class IPFS {
    /**
     * @param {Options} options
     */
    static create(options?: Options): Promise<IPFS>;
    /**
     * @param {Object} config
     * @param {Print} config.print
     * @param {StorageAPI} config.storage
     * @param {Options} config.options
     */
    constructor({ print, storage, options }: {
        print: Print;
        storage: StorageAPI;
        options: Options;
    });
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids/src/")): Promise<void>;
        start(): void;
        stop(): void;
    };
    name: import("./name");
    ipld: import("../interface/ipld").IPLD<any>;
    ipns: import("./ipns");
    pin: import("./pin");
    resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    block: import("./block");
    refs: ((ipfsPath: string | import("cids/src/"), options?: (import("./refs").RefsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<{
        ref: string;
        err?: null | undefined;
    } | {
        ref?: undefined;
        err: Error;
    }>) & {
        local: (options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
            ref: string;
        }>;
    };
    start: () => Promise<void>;
    stop: () => Promise<void>;
    dht: {
        get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
        put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        findProvs: (cid: import("cids/src/"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
        findPeer: (peerId: import("cids/src/") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
            id: string;
            addrs: import("multiaddr")[];
        }>;
        provide: (cids: import("cids/src/") | import("cids/src/")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
            id: import("cids/src/");
            addrs: import("multiaddr")[];
        }>;
    };
    pubsub: {
        subscribe: (topic: string, handler: (message: import("./pubsub").Message) => void, options?: import("../utils").AbortOptions | undefined) => Promise<void>;
        unsubscribe: (topic: string, handler?: ((message: import("./pubsub").Message) => void) | undefined, options?: import("../utils").AbortOptions | undefined) => Promise<void>;
        publish: (topic: string, data: Uint8Array, options: import("../utils").AbortOptions) => Promise<void>;
        ls: (options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
        peers: (topic: string, options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
    };
    dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    isOnline: () => boolean;
    id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").ID>;
    version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
    bitswap: import("./bitswap");
    bootstrap: import("./bootstrap");
    config: {
        getAll: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./config").IPFSConfig>;
        get: (key: string, options?: import("../utils").AbortOptions | undefined) => Promise<import("../interface/basic").ToJSON>;
        set: (key: string, value: import("../interface/basic").ToJSON, options?: import("../utils").AbortOptions | undefined) => Promise<void>;
        replace: (value: import("./config").IPFSConfig, options?: import("../utils").AbortOptions | undefined) => Promise<void>;
        profiles: {
            apply: (profileName: string, options?: any) => Promise<{
                original: import("./config").IPFSConfig;
                updated: import("./config").IPFSConfig;
            }>;
            list: (_options: any) => Promise<{
                name: string;
                description: string;
            }[]>;
        };
    };
    ping: (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
    add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
    addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
    cat: (ipfsPath: string | import("cids/src/"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    get: (ipfsPath: string | import("cids/src/"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    ls: (ipfsPath: string | import("cids/src/"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    dag: import("./dag");
    files: import("./files").MFS;
    key: import("./key");
    object: import("./object");
    repo: import("./repo");
    stats: import("./stats");
    swarm: import("./swarm");
    /**
     * `IPFS.create` will do the initialization. Keep this around for backwards
     * compatibility.
     *
     * @deprecated
     */
    init(): Promise<void>;
}
declare namespace IPFS {
    export { Options, IPFSOptions, ExperimentalOptions, StorageOptions, PreloadOptions, IPLDOptions, LibP2POptions, RelayOptions, InitOptions, StorageAPI, NetworkOptions, NetworkService, Repo, Print, Keychain, IPFSConfig, PeerId, LibP2P, PinManager, BlockService, BitSwap, IPLD, GCLock, Preload, MFSPreload, IPNS, Pin, Block, DagReader, Dag, Files, IsOnline, Resolve, Refs, DNS, Name, AbortOptions, CID, Multiaddr, IPLDBlock };
}
type Options = import("./storage").StorageOptions & IPFSOptions;
type Print = (...args: any[]) => void;
type StorageAPI = import("./storage");
/**
 * Options argument can be used to specify advanced configuration.
 */
type IPFSOptions = {
    /**
     * - Initialization options
     * the IPFS node.
     * Note that *initializing* a repo is different from creating an instance of
     * [`ipfs.Repo`](https://github.com/ipfs/js-ipfs-repo). The IPFS constructor
     * sets many special properties when initializing a repo, so you should usually
     * not try and call `repoInstance.init()` yourself.
     */
    init?: import("./storage").InitOptions | undefined;
    /**
     * - If `false`, do not automatically
     * start the IPFS node. Instead, you’ll need to manually call
     * [`node.start()`](https://github.com/ipfs/js-ipfs/blob/master/packages/ipfs/docs/MODULE.md#nodestart)
     * yourself.
     */
    start?: boolean | undefined;
    /**
     * - A passphrase to encrypt/decrypt your keys.
     */
    pass?: string | undefined;
    /**
     * - Prevents all logging output from the
     * IPFS node. (Default: `false`)
     */
    silent?: boolean | undefined;
    /**
     * - Configure circuit relay (see the [circuit relay tutorial]
     * (https://github.com/ipfs/js-ipfs/tree/master/examples/circuit-relaying)
     * to learn more).
     */
    relay?: RelayOptions | undefined;
    /**
     * - Run ipfs node offline. The node does
     * not connect to the rest of the network but provides a local API.
     */
    offline?: boolean | undefined;
    /**
     * - Configure remote preload nodes.
     * The remote will preload content added on this node, and also attempt to
     * preload objects requested by this node.
     */
    preload?: import("../preload").Options | undefined;
    /**
     * - Enable and configure
     * experimental features.
     */
    EXPERIMENTAL?: ExperimentalOptions | undefined;
    /**
     * - Modify the default IPFS node config. This
     * object will be *merged* with the default config; it will not replace it.
     * (Default: [`config-nodejs.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-nodejs.js)
     * in Node.js, [`config-browser.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-browser.js)
     * in browsers)
     */
    config?: import("./config").IPFSConfig | undefined;
    /**
     * - Modify the default IPLD config. This object
     * will be *merged* with the default config; it will not replace it. Check IPLD
     * [docs](https://github.com/ipld/js-ipld#ipld-constructor) for more information
     * on the available options. (Default: [`ipld.js`]
     * (https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld-nodejs.js) in Node.js, [`ipld-browser.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld-browser.js)
     * (https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld.js)
     * in browsers)
     */
    ipld?: import("../interface/ipld").Options | undefined;
    /**
     * - The libp2p option allows you to build
     * your libp2p node by configuration, or via a bundle function. If you are
     * looking to just modify the below options, using the object format is the
     * quickest way to get the default features of libp2p. If you need to create a
     * more customized libp2p node, such as with custom transports or peer/content
     * routers that need some of the ipfs data on startup, a custom bundle is a
     * great way to achieve this.
     * - You can see the bundle in action in the [custom libp2p example](https://github.com/ipfs/js-ipfs/tree/master/examples/custom-libp2p).
     * - Please see [libp2p/docs/CONFIGURATION.md](https://github.com/libp2p/js-libp2p/blob/master/doc/CONFIGURATION.md)
     * for the list of options libp2p supports.
     * - Default: [`libp2p-nodejs.js`](../src/core/runtime/libp2p-nodejs.js)
     * in Node.js, [`libp2p-browser.js`](../src/core/runtime/libp2p-browser.js) in
     * browsers.
     */
    libp2p?: LibP2POptions | Function;
    repoOwner?: boolean | undefined;
};
type ExperimentalOptions = {
    /**
     * - Enable pub-sub on IPNS. (Default: `false`)
     */
    ipnsPubsub?: boolean | undefined;
    /**
     * - Enable directory sharding. Directories that have many child objects will be represented by multiple DAG nodes instead of just one. It can improve lookup performance when a directory has several thousand files or more. (Default: `false`)
     */
    sharding?: boolean | undefined;
};
type StorageOptions = {
    /**
     * - The file path at which to store the
     * IPFS node’s data. Alternatively, you can set up a customized storage system
     * by providing an Repo implementation. (In browser default is 'ipfs').
     */
    repo?: string | import("../interface/repo").Repo<import("./config").IPFSConfig> | undefined;
    /**
     * - js-ipfs comes bundled with a tool
     * that automatically migrates your IPFS repository when a new version is
     * available.
     */
    repoAutoMigrate?: boolean | undefined;
    repoOwner?: boolean | undefined;
    ipld?: import("../interface/ipld").Options | undefined;
};
type PreloadOptions = {
    /**
     * - Whether to preload anything
     */
    enabled?: boolean | undefined;
    /**
     * - How many CIDs to cache
     */
    cache?: number | undefined;
    /**
     * - Which preload servers to use.
     * **NOTE:** nodes specified here should also be added to your node's bootstrap address list at `config.Boostrap`.
     */
    addresses?: string[] | undefined;
};
type IPLDOptions = import("../interface/ipld").Options;
type LibP2POptions = any;
type RelayOptions = {
    /**
     * - Enable circuit relay dialer and listener. (Default: `true`)
     */
    enabled?: boolean | undefined;
    hop?: {
        /**
         * - Make this node a relay (other nodes can connect *through* it). (Default: `false`)
         */
        enabled?: boolean | undefined;
        /**
         * - Make this an *active* relay node. Active relay nodes will attempt to dial a destin
         */
        active?: boolean | undefined;
    } | undefined;
};
type InitOptions = {
    /**
     * - Whether to remove built-in assets,
     * like the instructional tour and empty mutable file system, from the repo.
     */
    emptyRepo?: boolean | undefined;
    /**
     * - The type of key to use.
     */
    algorithm?: "Ed25519" | "RSA" | "secp256k1" | undefined;
    /**
     * - Number of bits to use in the generated key
     * pair (rsa only).
     */
    bits?: number | undefined;
    /**
     * - A pre-generated private key to use.
     * **NOTE: This overrides `bits`.**
     */
    privateKey?: string | import("peer-id") | undefined;
    /**
     * - A passphrase to encrypt keys. You should
     * generally use the top-level `pass` option instead of the `init.pass`
     * option (this one will take its value from the top-level option if not set).
     */
    pass?: string | undefined;
    /**
     * - Apply profile settings to config.
     */
    profiles?: string[] | undefined;
    /**
     * - Set to `false` to disallow
     * initialization if the repo does not already exist.
     */
    allowNew?: boolean | undefined;
};
type NetworkOptions = {
    peerId: import("peer-id");
    repo: import("../interface/repo").Repo<import("./config").IPFSConfig>;
    print: (...args: any[]) => void;
    options: import("./storage").StorageOptions & IPFSOptions;
};
type NetworkService = import("../utils/service")<import("./network").Options, import("./network")>;
type Repo = import("../interface/repo").Repo<import("./config").IPFSConfig>;
type Keychain = any;
type IPFSConfig = {
    Addresses: import("./config").AddressConfig;
    Profiles?: string | undefined;
    Bootstrap?: string[] | undefined;
    Discovery: import("./config").DiscoveryConfig;
    Datastore?: import("./config").DatastoreConfig | undefined;
    Identity?: import("./config").IdentityConfig | undefined;
    Keychain?: import("./config").KeychainConfig | undefined;
    Pubsub?: import("./config").PubsubConfig | undefined;
    Swarm?: import("./config").SwarmConfig | undefined;
    Routing?: import("./config").RoutingConfig | undefined;
};
type PeerId = import("peer-id");
type LibP2P = any;
type PinManager = import("./pin/pin-manager");
type BlockService = import("../interface/block-service").BlockService;
type BitSwap = import("../interface/bitswap").Bitswap;
type IPLD = import("../interface/ipld").IPLD<any>;
type GCLock = {
    readLock: () => Promise<() => void>;
    writeLock: () => Promise<() => void>;
};
type Preload = ((() => void) & {
    start: () => void;
    stop: () => void;
}) | {
    (path: string | import("cids/src/")): Promise<void>;
    start(): void;
    stop(): void;
};
type MFSPreload = {
    start(): Promise<void>;
    stop(): void;
};
type IPNS = import("./ipns");
type Pin = import("./pin");
type Block = import("./block");
type DagReader = {
    get: (ipfsPath: string | import("cids/src/"), options?: (import("./dag/get").GetOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./dag/get").DagEntry>;
    resolve: (ipfsPath: string | import("cids/src/"), options?: (import("./dag/resolve").ResolveOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./dag/resolve").ResolveResult>;
    tree: (ipfsPath: import("cids/src/"), options?: (import("./dag/tree").TreeOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
};
type Dag = import("./dag");
type Files = {
    stat: (path: string, options?: (import("./files/stat").StatOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./files/stat").Stat>;
    chmod: (path: string, mode: string | number, options?: (import("./files/chmod").ChmodOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    cp: (...args: [string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids/src/"), string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), string | import("cids/src/"), (import("./files/cp").CpOptions | undefined)?]) => Promise<void>;
    flush: (path: string, options?: import("../utils").AbortOptions | undefined) => Promise<import("cids/src/")>;
    mkdir: (path: string, options?: (import("./files/mkdir").MkdirOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    mv: (...args: [string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?]) => Promise<void>;
    rm: (...args: [string, (import("./files/rm").RmOptions | undefined)?] | [string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?]) => Promise<void>;
    touch: (path: string, options?: (import("./files/touch").TouchOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    write: (path: string, content: string | Uint8Array | AsyncIterable<Uint8Array> | Blob, options?: (import("./files/write").WriteOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    read: (path: string | import("cids/src/"), options?: (import("./files/read").ReadOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    ls: (path: string, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./files/ls").UnixFSEntry>;
};
type IsOnline = () => boolean;
type Resolve = (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
type Refs = (ipfsPath: string | import("cids/src/"), options?: (import("./refs").RefsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<{
    ref: string;
    err?: null | undefined;
} | {
    ref?: undefined;
    err: Error;
}>;
type DNS = (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
type Name = import("./name");
type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
type CID = import("cids/src/");
type Multiaddr = import("multiaddr");
type IPLDBlock = import("../interface/basic").Block;
//# sourceMappingURL=index.d.ts.map