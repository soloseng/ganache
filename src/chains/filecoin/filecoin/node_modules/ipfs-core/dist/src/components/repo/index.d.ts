export = RepoAPI;
declare class RepoAPI {
    /**
     * @param {Object} config
     * @param {GCLock} config.gcLock
     * @param {Pin} config.pin
     * @param {Repo} config.repo
     * @param {Refs} config.refs
     */
    constructor({ gcLock, pin, repo, refs }: {
        gcLock: GCLock;
        pin: Pin;
        repo: Repo;
        refs: Refs;
    });
    gc: (_options?: import("../../utils").AbortOptions | undefined) => AsyncIterable<import("./gc").Err | import("./gc").BlockID>;
    stat: (options?: import("../../utils").AbortOptions | undefined) => Promise<{
        numObjects: number;
        repoSize: number;
        repoPath: string;
        version: string;
        storageMax: number;
    }>;
    version: (options: import("../../utils").AbortOptions) => Promise<number>;
}
declare namespace RepoAPI {
    export { GCLock, Pin, Repo, Refs, AbortOptions };
}
type GCLock = {
    readLock: () => Promise<() => void>;
    writeLock: () => Promise<() => void>;
};
type Pin = import("../pin");
type Repo = import("../../interface/repo").Repo<import("../config").IPFSConfig>;
type Refs = (ipfsPath: string | import("cids/src/"), options?: (import("../refs").RefsOptions & import("../../utils").AbortOptions) | undefined) => AsyncIterable<{
    ref: string;
    err?: null | undefined;
} | {
    ref?: undefined;
    err: Error;
}>;
type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
//# sourceMappingURL=index.d.ts.map