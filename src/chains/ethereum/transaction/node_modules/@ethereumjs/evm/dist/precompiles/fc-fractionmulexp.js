"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.precompileFcFractionMulExp = void 0;
const util_1 = require("@ethereumjs/util");
const evm_1 = require("../evm");
const exceptions_1 = require("../exceptions");
const assert = require('assert');
// import assert from 'assert'
function precompileFcFractionMulExp(opts) {
    const gasUsed = BigInt(1050);
    assert(opts.data);
    if (opts.gasLimit < gasUsed) {
        return (0, evm_1.OOGResult)(opts.gasLimit);
    }
    const aNumerator = (0, util_1.bufferToBigInt)(opts.data.slice(0, 32));
    const aDenominator = (0, util_1.bufferToBigInt)(opts.data.slice(32, 64));
    const bNumerator = (0, util_1.bufferToBigInt)(opts.data.slice(64, 96));
    const bDenominator = (0, util_1.bufferToBigInt)(opts.data.slice(96, 128));
    const exponent = (0, util_1.bufferToBigInt)(opts.data.slice(128, 160));
    const decimals = (0, util_1.bufferToBigInt)(opts.data.slice(160, 192));
    // const aNumerator = new BN(opts.data.slice(0, 32))
    // const aDenominator = new BN(opts.data.slice(32, 64))
    // const bNumerator = new BN(opts.data.slice(64, 96))
    // const bDenominator = new BN(opts.data.slice(96, 128))
    // const exponent = new BN(opts.data.slice(128, 160))
    // const decimals = new BN(opts.data.slice(160, 192))
    // if (aDenominator.isZero() || bDenominator.isZero()) {
    if (aDenominator === BigInt(0) || bDenominator === BigInt(0)) {
        return {
            returnValue: Buffer.alloc(0),
            executionGasUsed: opts.gasLimit,
            exceptionError: new exceptions_1.EvmError(exceptions_1.ERROR.REVERT),
        };
    }
    const numeratorExp = aNumerator * bNumerator ** exponent;
    // const numeratorExp = aNumerator.mul(bNumerator.pow(exponent))
    const denominatorExp = aDenominator * bDenominator ** exponent;
    // const denominatorExp = aDenominator.mul(bDenominator.pow(exponent))
    const decimalAdjustment = BigInt(10) ** decimals;
    // const decimalAdjustment = new BN(10).pow(decimals)
    const numeratorDecimalAdjusted = (numeratorExp * decimalAdjustment) / denominatorExp;
    // const numeratorDecimalAdjusted = numeratorExp.mul(decimalAdjustment).div(denominatorExp)
    const denominatorDecimalAdjusted = decimalAdjustment;
    const numeratorBuf = (0, util_1.bigIntToBuffer)(numeratorDecimalAdjusted);
    const denominatorBuf = (0, util_1.bigIntToBuffer)(denominatorDecimalAdjusted);
    // const numeratorBuf = numeratorDecimalAdjusted.toArrayLike(Buffer, 'be', 32)
    // const denominatorBuf = denominatorDecimalAdjusted.toArrayLike(Buffer, 'be', 32)
    const numeratorPadded = (0, util_1.setLengthLeft)(numeratorBuf, 32);
    const denominatorPadded = (0, util_1.setLengthLeft)(denominatorBuf, 32);
    const returnValue = Buffer.concat([numeratorPadded, denominatorPadded]);
    return { returnValue, executionGasUsed: gasUsed };
}
exports.precompileFcFractionMulExp = precompileFcFractionMulExp;
//# sourceMappingURL=fc-fractionmulexp.js.map