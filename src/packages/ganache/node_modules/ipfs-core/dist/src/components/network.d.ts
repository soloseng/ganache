export = Network;
declare class Network {
    /**
     * @param {Options} options
     */
    static start({ peerId, repo, print, options }: Options): Promise<Network>;
    /**
     * @param {Network} network
     */
    static stop(network: Network): Promise<void>;
    /**
     * @param {PeerId} peerId
     * @param {LibP2P} libp2p
     * @param {BitSwap} bitswap
     */
    constructor(peerId: PeerId, libp2p: any, bitswap: BitSwap);
    peerId: import("peer-id");
    libp2p: any;
    bitswap: import("../interface/bitswap").Bitswap;
}
declare namespace Network {
    export { Online, Options, IPFSConfig, IPFSOptions, Repo, Print, LibP2P, BitSwap, PeerId, AbortOptions };
}
type Options = {
    peerId: PeerId;
    repo: Repo;
    print: Print;
    options: IPFSOptions;
};
type PeerId = import("peer-id");
type BitSwap = import("../interface/bitswap").Bitswap;
type Online = {
    libp2p: any;
    bitswap: BitSwap;
};
type IPFSConfig = {
    Addresses: import("./config").AddressConfig;
    Profiles?: string | undefined;
    Bootstrap?: string[] | undefined;
    Discovery: import("./config").DiscoveryConfig;
    Datastore?: import("./config").DatastoreConfig | undefined;
    Identity?: import("./config").IdentityConfig | undefined;
    Keychain?: import("./config").KeychainConfig | undefined;
    Pubsub?: import("./config").PubsubConfig | undefined;
    Swarm?: import("./config").SwarmConfig | undefined;
    Routing?: import("./config").RoutingConfig | undefined;
};
type IPFSOptions = import("./storage").StorageOptions & import(".").IPFSOptions;
type Repo = import("../interface/repo").Repo<import("./config").IPFSConfig>;
type Print = (...args: any[]) => void;
type LibP2P = any;
type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
//# sourceMappingURL=network.d.ts.map