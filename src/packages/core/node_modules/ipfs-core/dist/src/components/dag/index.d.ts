export = DagAPI;
declare class DagAPI {
    /**
     * Creates a reader part of the DAG API. This allows other APIs that require
     * reader parts of the DAG API to be instantiated before components required
     * by writer end are.
     *
     * @param {ReaderConfig} config
     * @returns {DagReader}
     */
    static reader(config: ReaderConfig): DagReader;
    /**
     * @param {Object} config
     * @param {IPLD} config.ipld
     * @param {Preload} config.preload
     * @param {Pin} config.pin
     * @param {GCLock} config.gcLock
     * @param {DagReader} config.dagReader
     */
    constructor({ ipld, pin, preload, gcLock, dagReader }: {
        ipld: IPLD;
        preload: Preload;
        pin: Pin;
        gcLock: GCLock;
        dagReader: DagReader;
    });
    get: (ipfsPath: string | import("cids/src/"), options?: (import("./get").GetOptions & import("../../utils").AbortOptions) | undefined) => Promise<import("./get").DagEntry>;
    resolve: (ipfsPath: string | import("cids/src/"), options?: (import("./resolve").ResolveOptions & import("../../utils").AbortOptions) | undefined) => Promise<import("./resolve").ResolveResult>;
    tree: (ipfsPath: import("cids/src/"), options?: (import("./tree").TreeOptions & import("../../utils").AbortOptions) | undefined) => AsyncIterable<string>;
    put: (dagNode: any, options?: (import("./put").WithCID & import("./put").OtherPutOptions & import("../../utils").AbortOptions) | (import("./put").WithCIDOptions & import("./put").OtherPutOptions & import("../../utils").AbortOptions) | undefined) => Promise<import("cids/src/")>;
}
declare namespace DagAPI {
    export { DagReader, ReaderConfig, IPLD, Preload, Pin, GCLock, CID, AbortOptions };
}
type ReaderConfig = {
    ipld: IPLD;
    preload: Preload;
};
type DagReader = {
    get: ReturnType<typeof createGet>;
    resolve: ReturnType<typeof createResolve>;
    tree: ReturnType<typeof createTree>;
};
type IPLD = import("../../interface/ipld").IPLD<any>;
type Preload = ((() => void) & {
    start: () => void;
    stop: () => void;
}) | {
    (path: string | import("cids/src/")): Promise<void>;
    start(): void;
    stop(): void;
};
type Pin = import("../pin");
type GCLock = {
    readLock: () => Promise<() => void>;
    writeLock: () => Promise<() => void>;
};
type CID = import("cids/src/");
type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
declare const createGet: ({ ipld, preload }: {
    ipld: import("../../interface/ipld").IPLD<any>;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids/src/")): Promise<void>;
        start(): void;
        stop(): void;
    };
}) => (ipfsPath: string | import("cids/src/"), options?: (import("./get").GetOptions & import("../../utils").AbortOptions) | undefined) => Promise<import("./get").DagEntry>;
declare const createResolve: ({ ipld, preload }: {
    ipld: import("../../interface/ipld").IPLD<any>;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids/src/")): Promise<void>;
        start(): void;
        stop(): void;
    };
}) => (ipfsPath: string | import("cids/src/"), options?: (import("./resolve").ResolveOptions & import("../../utils").AbortOptions) | undefined) => Promise<import("./resolve").ResolveResult>;
declare const createTree: ({ ipld, preload }: {
    ipld: import("../../interface/ipld").IPLD<any>;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids/src/")): Promise<void>;
        start(): void;
        stop(): void;
    };
}) => (ipfsPath: import("cids/src/"), options?: (import("./tree").TreeOptions & import("../../utils").AbortOptions) | undefined) => AsyncIterable<string>;
//# sourceMappingURL=index.d.ts.map