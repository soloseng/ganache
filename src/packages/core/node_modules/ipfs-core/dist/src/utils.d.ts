export var mergeOptions: {
    <T, U>(target: T, source: U): T & U;
    <T_1, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
};
export var OFFLINE_ERROR: string;
export var MFS_ROOT_KEY: any;
export var MFS_MAX_CHUNK_SIZE: number;
export var MFS_MAX_LINKS: number;
/**
 * Returns a well-formed ipfs Path.
 * The returned path will always be prefixed with /ipfs/ or /ipns/.
 *
 * @param  {string} pathStr - An ipfs-path, or ipns-path or a cid
 * @returns {string} - ipfs-path or ipns-path
 * @throws on an invalid @param pathStr
 */
export function normalizePath(pathStr: string): string;
/**
 * @param {Uint8Array|CID|string} path
 * @returns {string}
 */
export function normalizeCidPath(path: Uint8Array | import("cids/src/") | string): string;
/**
 * Resolve various styles of an ipfs-path to the hash of the target node.
 * Follows links in the path.
 *
 * Accepts formats:
 * - <base58 string>
 * - <base58 string>/link/to/venus
 * - /ipfs/<base58 string>/link/to/pluto
 * - multihash Buffer
 *
 * @param {import('./components').DagReader} dag
 * @param {CID | string} ipfsPath - A CID or IPFS path
 * @param {Object} [options] - Optional options passed directly to dag.resolve
 * @returns {Promise<CID>}
 */
export function resolvePath(dag: import('./components').DagReader, ipfsPath: import("cids/src/") | string, options?: any): Promise<import("cids/src/")>;
/**
 * @param {InputFile|UnixFSFile} file
 * @param {Object} [options]
 * @param {boolean} [options.includeContent]
 * @returns {IPFSEntry}
 */
export function mapFile(file: InputFile | UnixFSFile, options?: {
    includeContent?: boolean | undefined;
} | undefined): IPFSEntry;
export var withTimeoutOption: typeof import("ipfs-core-utils/src/with-timeout-option");
export function withTimeout<T>(promise: T | Promise<T>, _options?: AbortOptions | undefined): Promise<T>;
export type File = {
    type: 'file';
    cid: import("cids/src/");
    name: string;
    /**
     * - File path
     */
    path: string;
    /**
     * - File content
     */
    content?: AsyncIterable<Uint8Array> | undefined;
    mode?: number | undefined;
    mtime?: MTime | undefined;
    size: number;
    depth: number;
};
export type Directory = {
    type: 'dir';
    cid: import("cids/src/");
    name: string;
    /**
     * - Directory path
     */
    path: string;
    mode?: number | undefined;
    mtime?: MTime | undefined;
    size: number;
    depth: number;
};
export type IPFSEntry = File | Directory;
export type BaseFile = {
    cid: import("cids/src/");
    path: string;
    name: string;
};
export type InputFileExt = {
    unixfs?: undefined;
};
export type InputFile = BaseFile & InputFileExt;
export type UnixFSeExt = {
    content: () => AsyncIterable<Uint8Array>;
    unixfs: UnixFS;
};
export type UnixFSFile = BaseFile & UnixFSeExt;
export type UnixFS = {
    type: 'directory' | 'file' | 'dir';
    fileSize: () => number;
    content: () => AsyncIterable<Uint8Array>;
    mode: number;
    mtime: MTime;
};
export type MTime = {
    /**
     * - the number of seconds since (positive) or before
     * (negative) the Unix Epoch began
     */
    secs: number;
    /**
     * - the number of nanoseconds since the last full
     * second.
     */
    nsecs?: number | undefined;
};
export type Fn<ARGS extends any[], R> = (...args: ARGS) => R;
export type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
export type Mtime = {
    secs?: number | undefined;
    nsecs?: number | undefined;
};
export type Hrtime = [number, number];
export type PreloadOptions = {
    preload?: boolean | undefined;
};
//# sourceMappingURL=utils.d.ts.map